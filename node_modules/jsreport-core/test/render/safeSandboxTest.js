const should = require('should')
const core = require('../../index')

describe('sandbox', () => {
  let reporter

  beforeEach(async () => {
    reporter = core({ discover: false })

    reporter.use({
      name: 'render-testing',
      directory: __dirname,
      main: 'renderExtMain.js',
      worker: 'renderExtWorker.js'
    })

    await reporter.init()
  })

  afterEach(async () => {
    if (reporter) {
      await reporter.close()
    }
  })

  it('should be able to read normal sandbox props', async () => {
    const functions = {
      afterRender: (async (req, res, reporter) => {
        const result = await reporter.runInSandbox((context) => {
          return context.done(context.a)
        }, {
          getContext: () => {
            return {
              a: 'foo',
              done: (v) => {
                return `${v}_end`
              }
            }
          }
        })

        res.content = Buffer.from(JSON.stringify({
          sandboxResult: result
        }))
      }).toString()
    }

    const res = await reporter.render({
      template: {
        engine: 'none',
        content: JSON.stringify(functions),
        recipe: 'html'
      }
    })

    const result = JSON.parse(res.content.toString())

    should(result.sandboxResult).be.eql('foo_end')
  })

  it('should be able to set normal sandbox props', () => {
    const { run, sandbox } = safeSandbox({
      a: 'foo'
    })
    run('a = \'x\';')
    sandbox.a.should.be.eql('x')
  })

  it('should be able to set normal nested sandbox props', () => {
    const { run, sandbox } = safeSandbox({
      a: { b: 'a' }
    })
    run('a.b = \'x\';')
    sandbox.a.b.should.be.eql('x')
  })

  it('should be able to set props with sandboxReadOnly=false', () => {
    const { run, sandbox } = safeSandbox({
      a: 'a'
    }, {
      propertiesConfig: {
        a: {
          sandboxReadOnly: false
        }
      }
    })
    run('a = \'x\';')
    sandbox.a.should.be.eql('x')
  })

  it('should hide simple props', (done) => {
    const { run } = safeSandbox({
      done: (v) => {
        should(v).be.ok()
        done()
      },
      a: 'foo'
    }, {
      propertiesConfig: {
        a: {
          sandboxHidden: true
        }
      }
    })
    run('done(typeof a === \'undefined\')')
  })

  it('should hide nested props', (done) => {
    const { run } = safeSandbox({
      done: (v) => {
        should(v).not.be.ok()
        done()
      },
      a: { b: 'foo' }
    }, {
      propertiesConfig: {
        'a.b': {
          sandboxHidden: true
        }
      }
    })
    run('done(a.b)')
  })

  it('should make simple props readonly', () => {
    const { run } = safeSandbox({ a: { b: 'foo' } }, {
      propertiesConfig: {
        'a.b': {
          sandboxReadOnly: true
        }
      }
    })

    should.throws(() => run('a.b = 1'))
  })

  it('should make props readonly one level recursively', () => {
    const { run } = safeSandbox({ a: { b: { c: 'foo' } } }, {
      propertiesConfig: {
        'a.b': {
          sandboxReadOnly: true
        }
      }
    })

    should.throws(() => run('a.b.c = 1'))
  })

  it('should allow configure top level and inner level properties at the same time', () => {
    let isHidden = false

    const { run } = safeSandbox({
      a: { b: { c: 'foo' } },
      check: (result) => {
        isHidden = result
      }
    }, {
      propertiesConfig: {
        'a.b': {
          sandboxReadOnly: true
        },
        'a.b.c': {
          sandboxHidden: true
        }
      }
    })

    run('check(a.b.c === undefined)')

    should(isHidden).be.eql(true)
    should.throws(() => run('a.b.c = 1'))
  })

  it('should not fail when configuring top level and inner level properties but parent value is empty', () => {
    let isHidden = false

    const { run } = safeSandbox({
      a: {},
      check: (result) => {
        isHidden = result
      }
    }, {
      propertiesConfig: {
        'a.b': {
          sandboxReadOnly: true
        },
        'a.b.c': {
          sandboxHidden: true
        }
      }
    })

    run('check(a.b === undefined)')
    should(isHidden).be.eql(true)
  })

  it('restore should reveal hidden props', () => {
    const { restore } = safeSandbox({
      a: { b: 'foo' }
    }, {
      propertiesConfig: {
        'a.b': {
          sandboxHidden: true
        }
      }
    })

    restore().a.b.should.be.ok()
  })

  it('be able to stringify object when non-existent properties are configured', () => {
    const { sandbox } = safeSandbox({
      a: { b: 'foo' }
    }, {
      propertiesConfig: {
        'a.d': {
          sandboxHidden: true
        },
        'a.c': {
          sandboxReadOnly: true
        }
      }
    })

    should.doesNotThrow(() => {
      JSON.stringify(sandbox)
    })
  })

  it('should prevent constructor hacks', () => {
    const { run } = safeSandbox({})
    should.throws(() => run('this.constructor.constructor(\'return process\')().exit()'))
  })

  /*
  it.skip('executeScript should propagate back context.shared', async () => {
    fs.writeFileSync(path.join(__dirname, 'tmp', 'testScript.js'), `
      module.exports = async (inputs, logger, callback) => {
        await callback({})
        inputs.request.context.shared.array.push(3)
        return {}
      }
    `)

    fs.writeFileSync(path.join(__dirname, 'tmp', 'testCallback.js'), `
      module.exports = async (spec) => {
        originalReq.context.shared.array.push(2)
        return {}
      }
   `)

    reporter = core({ discover: false, templatingEngines: { strategy: 'dedicated-process' } })
    await reporter.init()

    const req = reporter.Request({ template: { }, context: { shared: { array: [1] } } })

    await reporter.executeScript({
      request: req
    }, {
      execModulePath: path.join(__dirname, 'tmp', 'testScript.js'),
      callback: async () => {
        return {}
      }
    }, req)

    req.context.shared.array.should.have.length(3)
    req.context.shared.array[0].should.be.eql(1)
    req.context.shared.array[1].should.be.eql(2)
    req.context.shared.array[2].should.be.eql(3)
  })
  */
})

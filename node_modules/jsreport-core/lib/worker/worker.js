const util = require('util')
const { workerData } = require('worker_threads')
// eslint-disable-next-line
const domain = require('domain')
const uuid = require('uuid').v4
const WorkerReporter = require('./workerReporter')

const callbackRequests = {}
const registry = new Map()
let reporter

async function reporterInit () {
  reporter = new WorkerReporter(workerData, registry)

  await reporter.init()

  return async function workerThreadExecute ({ waitForTaskRelease, managerPort }) {
    const execution = {}

    execution.promise = new Promise((resolve, reject) => {
      execution.resolve = resolve
      execution.reject = reject
    })

    managerPort.on('message', (payload) => {
      const { action } = payload

      switch (action) {
        case 'execute': {
          const { rid, data } = payload
          const { inputs, options } = data

          const threadLogger = createThreadLogger(rid, managerPort)

          inputs.registry = {
            set: (key, value) => registry.set(key, value),
            delete: (key) => registry.delete(key)
          }

          const runPromise = runModule({
            execModulePath: options.execModulePath,
            useReporter: options.useReporter,
            inputs,
            logger: threadLogger,
            callback: callback.bind(undefined, managerPort, rid)
          })

          runPromise.then((result) => {
            try {
              managerPort.postMessage({
                rid,
                action: 'execute-response',
                data: result
              })
            } catch (e) {
              // usually error about some value could not be cloned,
              // in this case we response with the error
              managerPort.postMessage({
                rid,
                action: 'execute-response',
                data: createErrorResponse(e)
              })
            }

            if (!waitForTaskRelease) {
              managerPort.close()
              execution.resolve()
            }
          })

          break
        }

        case 'callback-response': {
          // we will receive here the response of callback execution
          const { rid, cid, data } = payload

          callbackRequests[rid].responseHandler({
            cid,
            params: data
          })
          break
        }

        case 'release': {
          if (!waitForTaskRelease) {
            return
          }

          managerPort.close()
          execution.resolve()
          break
        }
      }
    })

    managerPort.postMessage({
      action: 'ready'
    })

    return execution.promise
  }
}

module.exports = reporterInit()

async function runModule ({ execModulePath, useReporter, inputs, logger, callback }) {
  return new Promise((resolve) => {
    // NOTE: we're using domains here intentionally,
    // we have tried to avoid its usage but unfortunately there is no other way to
    // ensure that we are handling all kind of errors that can occur in an external script,
    // but everything is ok because node.js will only remove domains when they found an alternative
    // and when that time comes, we just need to migrate to that alternative.
    const d = domain.create()

    d.on('error', (err) => {
      resolve(createErrorResponse(err))
    })

    d.run(() => {
      try {
        const module = require(execModulePath)
        const args = []

        if (useReporter) {
          args.push(reporter)
          args.push(inputs)
          args.push(logger)
          args.push(callback)
        } else {
          args.push(inputs)
          args.push(logger)
          args.push(callback)
        }

        const modulePromise = module(...args)

        if (!util.types.isPromise(modulePromise)) {
          throw new Error(`Module "${execModulePath}" does not return a promise, it can not be executed. make sure it is an async function or that it returns a promise`)
        }

        modulePromise.then((result) => {
          response = {
            data: result
          }

          resolve(response)
        }).catch((e) => resolve(createErrorResponse(e)))
      } catch (e) {
        resolve(createErrorResponse(e))
      }
    })
  })
}

function callback (managerPort, rid, ...args) {
  const cid = uuid()

  callbackRequests[rid] = callbackRequests[rid] || {}
  callbackRequests[rid].cbs = callbackRequests[rid].cbs || {}

  if (!callbackRequests[rid].responseHandler) {
    callbackRequests[rid].responseHandler = (resPayload) => {
      if (resPayload.params.length && resPayload.params[0]) {
        resPayload.params[0] = new Error(resPayload.params[0])
      }
      const cb = callbackRequests[rid].cbs[resPayload.cid]

      delete callbackRequests[rid].cbs[resPayload.cid]

      // eslint-disable-next-line standard/no-callback-literal
      cb(...resPayload.params)

      if (Object.keys(callbackRequests[rid].cbs).length === 0) {
        delete callbackRequests[rid]
      }
    }
  }

  callbackRequests[rid].cbs[cid] = args[args.length - 1]

  args.pop()

  // NOTE: no need to handle a possible error when sending here because it will be cached as
  // part of runModule error handler
  managerPort.postMessage({
    rid,
    cid,
    action: 'callback',
    data: args.sort()
  })
}

function createThreadLogger (rid, managerPort) {
  function logFn (level, ...args) {
    const lastArg = args.slice(-1)[0]
    let msgArgs = args
    let timestamp

    if (lastArg != null && typeof lastArg === 'object') {
      msgArgs = args.slice(0, -1)

      if (lastArg.timestamp != null) {
        timestamp = lastArg.timestamp
      }
    }

    const log = {
      timestamp: timestamp != null ? timestamp : new Date().getTime(),
      level: level,
      message: util.format.apply(util, msgArgs)
    }

    try {
      managerPort.postMessage({
        rid,
        action: 'log',
        data: log
      })
    } catch (e) {
      console.warn('Error in worker thread while trying to send log', e)
    }
  }

  return {
    debug: (...args) => logFn('debug', ...args),
    info: (...args) => logFn('info', ...args),
    warn: (...args) => logFn('warn', ...args),
    error: (...args) => logFn('error', ...args)
  }
}

function createErrorResponse (err) {
  const response = {
    error: {
      message: err.message,
      stack: err.stack
    }
  }

  return response
}

const Request = require('jsreport-core/lib/render/request')
const ListenerCollection = require('listener-collection')
const path = require('path')
const fs = require('fs')
const winston = require('winston')
const DocumentStore = require('./documentStoreWorker')
const ExtensionsManager = require('./extensionsManagerWorker')
const DebugTransport = require('../util/debugTransport')
const render = require('./render/render')
const omit = require('lodash.omit')
const createOrExtendError = require('../util/createError')
const noneEngine = require('./render/noneEngine')
const htmlRecipe = require('./render/htmlRecipe')
const getAvailableRenderTimeoutFn = require('../util/getAvailableRenderTimeout')
const tempFilesHandler = require('../util/tempFilesHandler')

module.exports = class ReporterWorker {
    constructor (options) {
      this.initializeListeners = new ListenerCollection()
      this.beforeRenderListeners = new ListenerCollection()
      this.afterRenderListeners = new ListenerCollection()
      this.renderErrorListeners = new ListenerCollection()
      this.afterTemplatingEnginesExecutedListeners = new ListenerCollection()
      this.validateRenderListeners = new ListenerCollection()
      this.closeListeners = new ListenerCollection()
      this.Request = Request

      this._initWinston()
      this.options = options
      this.extensionsManager = ExtensionsManager(this)
      this._configureWinstonTransports(this.options.logger)
      this.folders = {
        resolveEntityFromPath: (path, entitySet, req) => this.callback({
          action: 'folders.resolveEntityFromPath',
          requestId: req.context.requestId,
          data: {
            path,
            entitySet
          }
        })
      }
      this.initializeListeners.add('core', () => {
        this.afterRenderListeners.add('core', (request) => {
          this.logger.info(`Rendering request ${request.context.id} finished in ${(new Date().getTime() - request.context.startTimestamp)} ms`, request)
        })

        this.renderErrorListeners.add('core', (request, response, error) => {
          const logFn = error.weak ? this.logger.warn : this.logger.error
          logFn(`Rendering request ${request.context.id} finished with error in ${(new Date().getTime() - request.context.startTimestamp)} ms`, request)
        })
      })
      this.requestContextMetaConfigCollection = new WeakMap()
      this.requestModulesCache = new Map()
      const tmpContextMetaObj = JSON.parse(options.requestContextMetaConfigCollectionStr)
      for (let key in tmpContextMetaObj) {
        this.requestContextMetaConfigCollection.set(key, tmpContextMetaObj[key])
      }
    }

    async initForRequest(callback) {
      this.callback = callback
      this.documentStore = DocumentStore(callback)
    }

    async init () {
      await this.extensionsManager.init()

      this.extensionsManager.engines.push({
        name: 'none',
        execute: noneEngine
      })

      this.extensionsManager.recipes.push({
        name: 'html',
        execute: htmlRecipe
      })

      await this.initializeListeners.fire()
    }

    render (req, parentReq) {
      return render(this, req, parentReq)
    }


    createError (message, options = {}) {
      return createOrExtendError(message, options)
    }

    getAvailableRenderTimeout (req, defaultValue) {
      return getAvailableRenderTimeoutFn(this, req, defaultValue)
    }

    createListenerCollection () {
      return new ListenerCollection()
    }

    /**
     * Reads a file from the jsreport autocleanup temp directory (options.tempAutoCleanupDirectory)
     *
     * @public
     */
    async readTempFile (filename, opts) {
      if (this.options.tempAutoCleanupDirectory == null) {
        throw new Error('Can not use readTempFile when tempAutoCleanupDirectory option is not initialized, make sure to initialize jsreport first using jsreport.init()')
      }

      return tempFilesHandler.readTempFile(this.options.tempAutoCleanupDirectory, filename, opts)
    }

    /**
     * Creates a file into the jsreport autocleanup temp directory (options.tempAutoCleanupDirectory)
     * ensuring that the directory always exists
     *
     * @public
     */
    async writeTempFile (filenameFn, content, opts) {
      if (this.options.tempAutoCleanupDirectory == null) {
        throw new Error('Can not use writeTempFile when tempAutoCleanupDirectory option is not initialized, make sure to initialize jsreport first using jsreport.init()')
      }

      return tempFilesHandler.writeTempFile(this.options.tempAutoCleanupDirectory, filenameFn, content, opts)
    }

    /**
     * Reads a file as stream from the jsreport autocleanup temp directory (options.tempAutoCleanupDirectory)
     *
     * @public
     */
    async readTempFileStream (filename, opts) {
      if (this.options.tempAutoCleanupDirectory == null) {
        throw new Error('Can not use readTempFileStream when tempAutoCleanupDirectory option is not initialized, make sure to initialize jsreport first using jsreport.init()')
      }

      return tempFilesHandler.readTempFileStream(this.options.tempAutoCleanupDirectory, filename)
    }

    /**
     * Creates a file as stream into the jsreport autocleanup temp directory (options.tempAutoCleanupDirectory)
     * ensuring that the directory always exists
     *
     * @public
     */
    async writeTempFileStream (filenameFn, opts) {
      if (this.options.tempAutoCleanupDirectory == null) {
        throw new Error('Can not use writeTempFileStream when tempAutoCleanupDirectory option is not initialized, make sure to initialize jsreport first using jsreport.init()')
      }

      return tempFilesHandler.writeTempFileStream(this.options.tempAutoCleanupDirectory, filenameFn, opts)
    }

    /**
     * @public
     */
    getRequestContextMetaConfig (property) {
      const requestContextMetaConfig = this.requestContextMetaConfigCollection.get(this)

      if (property === undefined) {
        return requestContextMetaConfig
      }

      return requestContextMetaConfig[property]
    }


    _initWinston () {
      if (!winston.loggers.has('jsreport')) {
        const debugTransport = new DebugTransport()

        winston.loggers.add('jsreport', {
          transports: [debugTransport]
        })

        winston.loggers.get('jsreport').emitErrs = true

        winston.loggers.get('jsreport').on('error', function (err) {
          let dir
          let msg

          if (err.code === 'ENOENT') {
            dir = path.dirname(err.path)

            if (dir === '.') {
              msg = 'Error from logger (winston) while trying to use a file to store logs:'
            } else {
              msg = 'Error from logger (winston) while trying to use a file to store logs. If the directory "' + dir + '" does not exist, please create it:'
            }

            // make the error intentionally more visible to get the attention of the user
            console.error('------------------------')
            console.error(msg, err)
            console.error('------------------------')
          }
        })
      } else {
        if (!winston.loggers.get('jsreport').transports.debug) {
          winston.loggers.get('jsreport').add(DebugTransport)
        }
      }

      this.logger = winston.loggers.get('jsreport')
      this.logger.rewriters.push(function (level, msg, meta) {
        // detecting if meta is jsreport request object
        if (meta != null && meta.context) {
          meta.context.logs = meta.context.logs || []

          meta.context.logs.push({
            level: level,
            message: msg,
            timestamp: meta.timestamp || new Date().getTime()
          })

          // excluding non relevant properties for the log
          return Object.assign({}, omit(meta, ['template', 'options', 'data', 'context', 'timestamp']))
        }

        return meta
      })
    }

  _configureWinstonTransports (_transports) {
    var transports = _transports || {}

    var knownTransports = {
      debug: DebugTransport,
      memory: winston.transports.Memory,
      console: winston.transports.Console,
      file: winston.transports.File,
      http: winston.transports.Http
    }

    var knownOptions = ['transport', 'module', 'enabled']

    Object.keys(transports).forEach((transpName) => {
      const logger = this.logger
      // NOTE: omit 'handleExceptions', 'humanReadableUnhandledException' options to avoid winston exiting the process manually in thread
      // we want that it ends in uncaught exception instead
      const transpOptions = omit(transports[transpName], ['handleExceptions', 'humanReadableUnhandledException'])
      let transportModule

      if (!transpOptions || typeof transpOptions !== 'object' || Array.isArray(transpOptions)) {
        return
      }

      if (typeof transpOptions.transport !== 'string' || transpOptions.transport === '') {
        throw new Error(
          'invalid option for transport object "' + transpName +
        '", option "transport" is not specified or has an incorrect value, must be a string with a valid value. check your "logger" config'
        )
      }

      if (typeof transpOptions.level !== 'string' || transpOptions.level === '') {
        throw new Error(
          'invalid option for transport object "' + transpName +
        '", option "level" is not specified or has an incorrect value, must be a string with a valid value. check your "logger" config'
        )
      }

      if (transpOptions.enabled === false) {
        return
      }

      if (knownTransports[transpOptions.transport]) {
        if (!logger.transports[transpName]) {
          logger.add(knownTransports[transpOptions.transport], Object.assign(omit(transpOptions, knownOptions), {
            name: transpName
          }))
        }
      } else {
        if (transpOptions.module == null) {
          throw new Error(
            'invalid option for transport object "' + transpName +
          '", option "transport" has an unknown transport type: "' + transpOptions.transport + '". check your "logger" config'
          )
        }

        if (typeof transpOptions.module !== 'string') {
          throw new Error(
            'invalid option for transport object "' + transpName +
          '", option "module" has an incorrect value, must be a string with a module name. check your "logger" config'
          )
        }

        try {
          transportModule = require(transpOptions.module)

          if (typeof winston.transports[transpOptions.transport] === 'function') {
            transportModule = winston.transports[transpOptions.transport]
          } else if (transportModule && typeof transportModule[transpOptions.transport] === 'function') {
            transportModule = transportModule[transpOptions.transport]
          }

          if (typeof transportModule !== 'function') {
            throw new Error(
              'invalid option for transport object "' + transpName +
            '", module "' + transpOptions.module + '" does not export a valid transport. check your "logger" config'
            )
          }
        } catch (e) {
          if (e.code === 'MODULE_NOT_FOUND') {
            throw new Error(
              'invalid option for transport object "' + transpName +
            '", module "' + transpOptions.module +
            '" in "module" option could not be found. are you sure that you have installed it?. check your "logger" config'
            )
          }

          throw e
        }

        if (!logger.transports[transpName]) {
          logger.add(transportModule, Object.assign(omit(transpOptions, knownOptions), {
            name: transpName
          }))
        }
      }
    })
  }
}

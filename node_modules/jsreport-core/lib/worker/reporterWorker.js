const Request = require('jsreport-core/lib/render/request')
const ListenerCollection = require('listener-collection')
const path = require('path')
const fs = require('fs')
const winston = require('winston')
const DocumentStore = require('./documentStoreWorker')
const Promise = require('bluebird')
const ExtensionsManager = require('./extensionsManagerWorker')
const DebugTransport = require('../util/debugTransport')
const render = require('./render/render')
const omit = require('lodash.omit')
const createOrExtendError = require('../util/createError')
const noneEngine = require('./render/noneEngine')
const htmlRecipe = require('./render/htmlRecipe')

module.exports = class ReporterWorker {
    constructor (options, callback) {
      this.initializeListeners = new ListenerCollection()
      this.beforeRenderListeners = new ListenerCollection()
      this.afterRenderListeners = new ListenerCollection()
      this.renderErrorListeners = new ListenerCollection()
      this.afterTemplatingEnginesExecutedListeners = new ListenerCollection()
      this.validateRenderListeners = new ListenerCollection()
      this.closeListeners = new ListenerCollection()
      this.callback = callback
      
      this.Request = Request
      this.documentStore = DocumentStore(callback)

      this._initWinston()      
      this.options = options  
      this.extensionsManager = ExtensionsManager(this)   
      this._configureWinstonTransports(this.options.logger)
      
    }

    async init () {
      await this.extensionsManager.init()    

      this.extensionsManager.engines.push({
        name: 'none',
        execute: noneEngine 
      })

      this.extensionsManager.recipes.push({
        name: 'html',
        execute: htmlRecipe
      })
    }

    render (req, parentReq) {
      return render(this, req, parentReq)
    }


    createError (message, options = {}) {
      return createOrExtendError(message, options)
    }

    _initWinston () {
      if (!winston.loggers.has('jsreport')) {
        const debugTransport = new DebugTransport()
  
        winston.loggers.add('jsreport', {
          transports: [debugTransport]
        })
  
        winston.loggers.get('jsreport').emitErrs = true
  
        winston.loggers.get('jsreport').on('error', function (err) {
          let dir
          let msg
  
          if (err.code === 'ENOENT') {
            dir = path.dirname(err.path)
  
            if (dir === '.') {
              msg = 'Error from logger (winston) while trying to use a file to store logs:'
            } else {
              msg = 'Error from logger (winston) while trying to use a file to store logs. If the directory "' + dir + '" does not exist, please create it:'
            }
  
            // make the error intentionally more visible to get the attention of the user
            console.error('------------------------')
            console.error(msg, err)
            console.error('------------------------')
          }
        })
      } else {
        if (!winston.loggers.get('jsreport').transports.debug) {
          winston.loggers.get('jsreport').add(DebugTransport)
        }
      }
  
      this.logger = winston.loggers.get('jsreport')
      this.logger.rewriters.push(function (level, msg, meta) {
        // detecting if meta is jsreport request object
        if (meta != null && meta.context) {
          meta.context.logs = meta.context.logs || []
  
          meta.context.logs.push({
            level: level,
            message: msg,
            timestamp: meta.timestamp || new Date().getTime()
          })
  
          // excluding non relevant properties for the log
          return Object.assign({}, omit(meta, ['template', 'options', 'data', 'context', 'timestamp']))
        }
  
        return meta
      })
    }
  
  _configureWinstonTransports (_transports) {
    var transports = _transports || {}

    var knownTransports = {
      debug: DebugTransport,
      memory: winston.transports.Memory,
      console: winston.transports.Console,
      file: winston.transports.File,
      http: winston.transports.Http
    }

    var knownOptions = ['transport', 'module', 'enabled']

    Object.keys(transports).forEach((transpName) => {
      const logger = this.logger
      const transpOptions = transports[transpName]
      let transportModule

      if (!transpOptions || typeof transpOptions !== 'object' || Array.isArray(transpOptions)) {
        return
      }

      if (typeof transpOptions.transport !== 'string' || transpOptions.transport === '') {
        throw new Error(
          'invalid option for transport object "' + transpName +
        '", option "transport" is not specified or has an incorrect value, must be a string with a valid value. check your "logger" config'
        )
      }

      if (typeof transpOptions.level !== 'string' || transpOptions.level === '') {
        throw new Error(
          'invalid option for transport object "' + transpName +
        '", option "level" is not specified or has an incorrect value, must be a string with a valid value. check your "logger" config'
        )
      }

      if (transpOptions.enabled === false) {
        return
      }

      if (knownTransports[transpOptions.transport]) {
        if (!logger.transports[transpName]) {
          logger.add(knownTransports[transpOptions.transport], Object.assign(omit(transpOptions, knownOptions), {
            name: transpName
          }))
        }
      } else {
        if (transpOptions.module == null) {
          throw new Error(
            'invalid option for transport object "' + transpName +
          '", option "transport" has an unknown transport type: "' + transpOptions.transport + '". check your "logger" config'
          )
        }

        if (typeof transpOptions.module !== 'string') {
          throw new Error(
            'invalid option for transport object "' + transpName +
          '", option "module" has an incorrect value, must be a string with a module name. check your "logger" config'
          )
        }

        try {
          transportModule = require(transpOptions.module)

          if (typeof winston.transports[transpOptions.transport] === 'function') {
            transportModule = winston.transports[transpOptions.transport]
          } else if (transportModule && typeof transportModule[transpOptions.transport] === 'function') {
            transportModule = transportModule[transpOptions.transport]
          }

          if (typeof transportModule !== 'function') {
            throw new Error(
              'invalid option for transport object "' + transpName +
            '", module "' + transpOptions.module + '" does not export a valid transport. check your "logger" config'
            )
          }
        } catch (e) {
          if (e.code === 'MODULE_NOT_FOUND') {
            throw new Error(
              'invalid option for transport object "' + transpName +
            '", module "' + transpOptions.module +
            '" in "module" option could not be found. are you sure that you have installed it?. check your "logger" config'
            )
          }

          throw e
        }

        if (!logger.transports[transpName]) {
          logger.add(transportModule, Object.assign(omit(transpOptions, knownOptions), {
            name: transpName
          }))
        }
      }
    })
  }
}
  
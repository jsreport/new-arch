const path = require('path')
const fs = require('fs')
const omit = require('lodash.omit')
const ExtensionsManager = require('./extensionsManager')
const DocumentStore = require('./documentStore')
const Folders = require('./folders')
const createLogger = require('./logger')
const render = require('./render/render')
const createNoneEngine = require('./render/noneEngine')
const htmlRecipe = require('./render/htmlRecipe')
const Reporter = require('../shared/reporter')

class WorkerReporter extends Reporter {
  #registry
  #initialized
  #requestContextMetaConfigCollection

  constructor (options, extensionsDefs, registry) {
    super(options)

    this.#registry = registry
    this.#initialized = false
    this.#requestContextMetaConfigCollection = new Map()

    this.requestModulesCache = new Map()

    this.beforeRenderListeners = this.createListenerCollection()
    this.afterTemplatingEnginesExecutedListeners = this.createListenerCollection()
    this.validateRenderListeners = this.createListenerCollection()

    this.logger = createLogger(registry)

    this.extensionsManager = ExtensionsManager(this, extensionsDefs)

    this.initializeListeners.add('core', () => {
      this.afterRenderListeners.add('core', (request) => {
        this.logger.info(`Rendering request ${request.context.id} finished in ${(new Date().getTime() - request.context.startTimestamp)} ms`, request)
      })

      this.renderErrorListeners.add('core', (request, response, error) => {
        const logFn = error.weak ? this.logger.warn : this.logger.error
        logFn(`Rendering request ${request.context.id} finished with error in ${(new Date().getTime() - request.context.startTimestamp)} ms`, request)
      })
    })
  }

  async init () {
    if (this.#initialized === true) {
      throw new Error('jsreport already initialized. Make sure init is called only once')
    }

    await this.extensionsManager.init()

    this.folders = Folders(this.#registry)
    this.documentStore = DocumentStore(this.#registry)

    this.addRequestContextMetaConfig('id', { sandboxReadOnly: true })
    this.addRequestContextMetaConfig('reportCounter', { sandboxReadOnly: true })
    this.addRequestContextMetaConfig('startTimestamp', { sandboxReadOnly: true })
    this.addRequestContextMetaConfig('logs', { sandboxReadOnly: true })
    this.addRequestContextMetaConfig('isChildRequest', { sandboxReadOnly: true })
    this.addRequestContextMetaConfig('originalInputDataIsEmpty', { sandboxReadOnly: true })
    this.addRequestContextMetaConfig('skipModificationDateUpdate', { sandboxHidden: true })

    const { compile: compileNone, execute: executeNone } = createNoneEngine()

    this.extensionsManager.engines.push({
      name: 'none',
      compile: compileNone,
      execute: executeNone
    })

    this.extensionsManager.recipes.push({
      name: 'html',
      execute: htmlRecipe
    })

    await this.initializeListeners.fire()

    this.#initialized = true
  }

  /**
   * @public
   */
  addRequestContextMetaConfig (property, options) {
    this.#requestContextMetaConfigCollection.set(property, options)
  }

  /**
   * @public
   */
  getRequestContextMetaConfig (property) {
    if (property === undefined) {
      const all = {}

      for (const [key, value] of this.#requestContextMetaConfigCollection.entries()) {
        all[key] = value
      }

      return all
    }

    return this.#requestContextMetaConfigCollection.get(property)
  }

  render (req, parentReq) {
    return render(this, req, parentReq)
  }
}

module.exports = WorkerReporter

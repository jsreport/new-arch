const Request = require('jsreport-core/lib/render/request')
const path = require('path')
const fs = require('fs')
const omit = require('lodash.omit')
const ExtensionsManager = require('./extensionsManagerWorker')
const DocumentStore = require('./documentStoreWorker')
const Folders = require('./foldersWorker')
const createLogger = require('./loggerWorker')
const render = require('./render/render')
const Reporter = require('../reporter')
const noneEngine = require('./render/noneEngine')
const htmlRecipe = require('./render/htmlRecipe')

class WorkerReporter extends Reporter {
  #registry
  #initialized

  constructor (options, registry) {
    super(options)

    this.#registry = registry
    this.#initialized = false

    this.beforeRenderListeners = this.createListenerCollection()
    this.afterTemplatingEnginesExecutedListeners = this.createListenerCollection()
    this.validateRenderListeners = this.createListenerCollection()

    this.logger = createLogger(registry)

    this.extensionsManager = ExtensionsManager(this)

    this.initializeListeners.add('core', () => {
      this.afterRenderListeners.add('core', (request) => {
        this.logger.info(`Rendering request ${request.context.id} finished in ${(new Date().getTime() - request.context.startTimestamp)} ms`, request)
      })

      this.renderErrorListeners.add('core', (request, response, error) => {
        const logFn = error.weak ? this.logger.warn : this.logger.error
        logFn(`Rendering request ${request.context.id} finished with error in ${(new Date().getTime() - request.context.startTimestamp)} ms`, request)
      })
    })

    this.requestContextMetaConfigCollection = new WeakMap()
    this.requestModulesCache = new Map()

    const tmpContextMetaObj = JSON.parse(options.requestContextMetaConfigCollectionStr)

    for (let key in tmpContextMetaObj) {
      this.requestContextMetaConfigCollection.set(key, tmpContextMetaObj[key])
    }
  }

  async init () {
    if (this.#initialized === true) {
      throw new Error('jsreport already initialized. Make sure init is called only once')
    }

    await this.extensionsManager.init()

    this.folders = Folders(this.#registry)
    this.documentStore = DocumentStore(this.#registry)

    this.extensionsManager.engines.push({
      name: 'none',
      execute: noneEngine
    })

    this.extensionsManager.recipes.push({
      name: 'html',
      execute: htmlRecipe
    })

    await this.initializeListeners.fire()

    this.#initialized = true
  }

  render (req, parentReq) {
    return render(this, req, parentReq)
  }

  /**
   * @public
   */
  getRequestContextMetaConfig (property) {
    const requestContextMetaConfig = this.requestContextMetaConfigCollection.get(this)

    if (property === undefined) {
      return requestContextMetaConfig
    }

    return requestContextMetaConfig[property]
  }
}

module.exports = WorkerReporter

"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('string_decoder'),
    StringDecoder = _require.StringDecoder;

var fs = require('fs');

var _require2 = require('stream'),
    Transform = _require2.Transform;

var _require3 = require('xmldom'),
    DOMParser = _require3.DOMParser;

var Archiver = require('archiver');

var unzip = require('unzipper');

var streamifier = require('streamifier');

var tmp = require('tmp');

var StreamBuf = require('../../utils/stream-buf');

var RelType = require('../../xlsx/rel-type');

var StylesXform = require('../../xlsx/xform/style/styles-xform');

var SharedStrings = require('../../utils/shared-strings');

var DefinedNames = require('../../doc/defined-names');

var CoreXform = require('../../xlsx/xform/core/core-xform');

var RelationshipsXform = require('../../xlsx/xform/core/relationships-xform');

var ContentTypesXform = require('../../xlsx/xform/core/content-types-xform');

var AppXform = require('../../xlsx/xform/core/app-xform');

var WorkbookXform = require('../../xlsx/xform/book/workbook-xform');

var SharedStringsXform = require('../../xlsx/xform/strings/shared-strings-xform');

var WorksheetWriter = require('./worksheet-writer');

var theme1Xml = require('../../xlsx/xml/theme1.js');

var WorkbookWriter =
/*#__PURE__*/
function () {
  function WorkbookWriter(options) {
    _classCallCheck(this, WorkbookWriter);

    options = options || {};
    this.created = options.created || new Date();
    this.modified = options.modified || this.created;
    this.creator = options.creator || 'ExcelJS';
    this.lastModifiedBy = options.lastModifiedBy || 'ExcelJS';
    this.lastPrinted = options.lastPrinted; // using shared strings creates a smaller xlsx file but may use more memory

    this.useSharedStrings = options.useSharedStrings || false;
    this.sharedStrings = new SharedStrings(); // style manager

    if (options.template) {
      this.styles = new StylesXform(true);
    } else {
      this.styles = options.useStyles ? new StylesXform(true) : new StylesXform.Mock(true);
    } // defined names


    this._definedNames = new DefinedNames();
    this._worksheets = [];
    this._tmpWorksheets = new Map();
    this._cellStylesCache = new Map();
    this.views = [];
    this.zipOptions = options.zip;
    this.media = [];
    this.commentRefs = [];

    if (options.template) {
      this.templateBuf = options.template;
      this.templateWrites = [];
      this.templateInfo = {};
      this.templateZip = unzip.Parse();
    }

    this.zip = Archiver('zip', this.zipOptions);

    if (options.stream) {
      this.stream = options.stream;
    } else if (options.filename) {
      this.stream = fs.createWriteStream(options.filename);
    } else {
      this.stream = new StreamBuf();
    }

    this.zip.pipe(this.stream);

    if (options.template) {
      this.promise = new Promise(function (resolve) {
        return resolve();
      });
    } else {
      // these bits can be added right now
      this.promise = Promise.all([this.addThemes(), this.addOfficeRels()]);
    }
  }

  _createClass(WorkbookWriter, [{
    key: "_getNextWorksheetId",
    value: function _getNextWorksheetId(name) {
      var id;

      if (this.templateInfo) {
        var existingWorkSheet = this.templateInfo.sheets.find(function (s) {
          return s.name === name;
        });

        if (existingWorkSheet) {
          id = existingWorkSheet.sheetFileId;
        } else {
          id = this.nextId;
        }
      } else {
        id = this.nextId;
      }

      return id;
    }
  }, {
    key: "_openStream",
    value: function _openStream(path, sheetId) {
      var stream = new StreamBuf({
        bufSize: 65536,
        batch: true
      });
      var isWorksheet = sheetId != null;

      if (isWorksheet && this._tmpWorksheets.has(sheetId)) {
        var tmpWorksheet = this._tmpWorksheets.get(sheetId);

        tmpWorksheet.zipEntryPath = path;
        var tmpWriteStream = fs.createWriteStream(tmpWorksheet.tmpPath);
        tmpWorksheet.waitComplete = new Promise(function (resolve, reject) {
          tmpWriteStream.on('error', reject);
          tmpWriteStream.on('finish', resolve);
        });
        stream.pipe(tmpWriteStream);
      } else {
        this.zip.append(stream, {
          name: path
        });
      }

      stream.on('finish', function () {
        stream.emit('zipped');
      });
      return stream;
    }
  }, {
    key: "_commitWorksheets",
    value: function _commitWorksheets() {
      var commitWorksheet = function commitWorksheet(worksheet) {
        if (!worksheet.committed) {
          return new Promise(function (resolve) {
            worksheet.stream.on('zipped', function () {
              resolve();
            });
            worksheet.commit();
          });
        }

        return Promise.resolve();
      }; // if there are any uncommitted worksheets, commit them now and wait


      var promises = this._worksheets.map(commitWorksheet);

      if (promises.length) {
        return Promise.all(promises);
      }

      return Promise.resolve();
    }
  }, {
    key: "waitForTemplateParse",
    value: function () {
      var _waitForTemplateParse = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var _this = this;

        var templateStream, files, pendingOperations, waitingWorkSheets, workbookDoc, relsDoc, lastSheetId, lastSheetFileId, sheets, lastWorkbookRelsId;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                templateStream = streamifier.createReadStream(this.templateBuf);
                files = {};
                pendingOperations = [];
                waitingWorkSheets = [];
                _context.next = 6;
                return new Promise(function (resolve, reject) {
                  _this.templateZip.on('entry', function (entry) {
                    switch (entry.path) {
                      case '[Content_Types].xml':
                      case 'xl/styles.xml':
                      case 'xl/workbook.xml':
                      case 'xl/_rels/workbook.xml.rels':
                      case 'xl/calcChain.xml':
                        pendingOperations.push(parseXMLFile(files, entry));
                        break;

                      default:
                        if (entry.path.match(/xl\/worksheets\/sheet\d+[.]xml/)) {
                          pendingOperations.push(new Promise(function (_resolve, _reject) {
                            // eslint-disable-next-line consistent-return
                            tmp.file(function (err, tmpFilePath) {
                              if (err) {
                                return reject(err);
                              }

                              var tempStream = fs.createWriteStream(tmpFilePath);
                              waitingWorkSheets.push({
                                ref: entry.path,
                                path: tmpFilePath
                              });
                              entry.on('error', _reject);
                              tempStream.on('error', _reject);
                              tempStream.on('finish', _resolve);
                              entry.pipe(tempStream);
                            });
                          }));
                        } else {
                          _this.templateWrites.push(new Promise(function (_resolve) {
                            _this.zip.append(entry, {
                              name: entry.path
                            });

                            _resolve();
                          }));
                        }

                        break;
                    }
                  });

                  _this.templateZip.on('close', function () {
                    resolve();
                  });

                  _this.templateZip.on('error', reject);

                  templateStream.pipe(_this.templateZip);
                });

              case 6:
                _context.next = 8;
                return Promise.all(pendingOperations);

              case 8:
                this.templateInfo.filesDocuments = files;
                workbookDoc = this.templateInfo.filesDocuments['xl/workbook.xml'].doc;
                relsDoc = this.templateInfo.filesDocuments['xl/_rels/workbook.xml.rels'].doc;
                sheets = Array.from(workbookDoc.getElementsByTagName('sheet')).map(function (sheetNode) {
                  var sheetId = parseInt(sheetNode.getAttribute('sheetId'), 10);
                  var rId = sheetNode.getAttribute('r:id');
                  var targetRNode = Array.from(relsDoc.getElementsByTagName('Relationship')).find(function (rNode) {
                    return rNode.getAttribute('Id') === rId;
                  });
                  var sheetFile = targetRNode.getAttribute('Target');
                  var sheetFileId = parseInt(sheetFile.match(/worksheets\/sheet(\d+)[.]xml/)[1], 10);
                  var sheetFileFound = waitingWorkSheets.find(function (w) {
                    return w.ref === "xl/worksheets/sheet".concat(sheetFileId, ".xml");
                  });

                  if (lastSheetId == null || lastSheetId < sheetId) {
                    lastSheetId = sheetId;
                  }

                  if (lastSheetFileId == null || lastSheetFileId < sheetFileId) {
                    lastSheetFileId = sheetFileId;
                  }

                  return {
                    id: sheetId,
                    name: sheetNode.getAttribute('name'),
                    rId: rId,
                    sheetFile: sheetFile,
                    sheetFileId: sheetFileId,
                    sheetFileSrc: {
                      path: sheetFileFound.path
                    }
                  };
                }); // take existing styles from template as the base of new styles

                _context.next = 14;
                return this.styles.parseStream(streamifier.createReadStream(this.templateInfo.filesDocuments['xl/styles.xml'].originalSrc));

              case 14:
                lastWorkbookRelsId = Array.from(relsDoc.getElementsByTagName('Relationship')).reduce(function (acu, relNode) {
                  var rId = relNode.getAttribute('Id');
                  var rIdNumber = parseInt(rId.match(/rId(\d+)/)[1], 10);

                  if (rIdNumber > acu) {
                    return rIdNumber;
                  }

                  return acu;
                }, 0);
                this.templateInfo.sheets = sheets;
                this.templateInfo.lastSheetId = lastSheetId;
                this.templateInfo.lastSheetFileId = lastSheetFileId;
                this.templateInfo.lastWorkbookRelsId = lastWorkbookRelsId;

              case 19:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function waitForTemplateParse() {
        return _waitForTemplateParse.apply(this, arguments);
      }

      return waitForTemplateParse;
    }()
  }, {
    key: "commit",
    value: function () {
      var _commit = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var _this2 = this;

        var newWorksheets, newWorksheetsColsWidth, replacedWorksheets, _loop, _i, _Object$entries, tmpWorksheetCompletePromises, worksheetsToCopy, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _step2$value, sheetId, tmpWorksheet, _loop2, _i4, _worksheetsToCopy, result;

        return regeneratorRuntime.wrap(function _callee2$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.promise;

              case 2:
                if (!this.templateWrites) {
                  _context3.next = 5;
                  break;
                }

                _context3.next = 5;
                return Promise.all(this.templateWrites);

              case 5:
                _context3.next = 7;
                return this.addMedia();

              case 7:
                newWorksheets = [];
                newWorksheetsColsWidth = new Map();

                this._worksheets.forEach(function (w) {
                  if (w == null) {
                    return;
                  } // eslint-disable-next-line no-underscore-dangle


                  if (Array.isArray(w._columns)) {
                    // eslint-disable-next-line no-underscore-dangle
                    newWorksheetsColsWidth.set(w.id, w._columns.map(function (c) {
                      return {
                        // eslint-disable-next-line no-underscore-dangle
                        number: c._number,
                        width: c.width
                      };
                    }));
                  }

                  newWorksheets.push(w);
                });

                replacedWorksheets = [];

                if (this.templateInfo) {
                  this.templateInfo.sheets.forEach(function (sheet) {
                    var existingWorksheetIndex = newWorksheets.findIndex(function (w) {
                      return w.name === sheet.name;
                    });

                    if (existingWorksheetIndex !== -1) {
                      sheet.replaced = true; // eslint-disable-next-line no-underscore-dangle

                      sheet.calcCells = newWorksheets[existingWorksheetIndex]._calcCells;
                      newWorksheets.splice(existingWorksheetIndex, 1);
                      return;
                    }

                    _this2.zip.append(fs.createReadStream(sheet.sheetFileSrc.path), {
                      name: "xl/worksheets/sheet".concat(sheet.sheetFileId, ".xml")
                    });
                  });
                  replacedWorksheets = this.templateInfo.sheets.filter(function (s) {
                    return s.replaced === true;
                  });
                }

                _context3.next = 14;
                return this._commitWorksheets();

              case 14:
                if (!this.templateInfo) {
                  _context3.next = 19;
                  break;
                }

                _loop = function _loop() {
                  var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                      fileName = _Object$entries$_i[0],
                      _Object$entries$_i$ = _Object$entries$_i[1],
                      fileDoc = _Object$entries$_i$.doc,
                      originalSrc = _Object$entries$_i$.originalSrc;

                  var content = originalSrc;

                  if (fileName === '[Content_Types].xml' && newWorksheets.length > 0) {
                    var sheetNodeRef = Array.from(fileDoc.getElementsByTagName('Override')).find(function (node) {
                      return node.getAttribute('PartName') === "/xl/worksheets/sheet".concat(_this2.templateInfo.lastSheetFileId, ".xml");
                    }); // eslint-disable-next-line no-restricted-syntax

                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;

                    try {
                      for (var _iterator = newWorksheets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var newWorksheet = _step.value;
                        var newWorkSheetRef = sheetNodeRef.cloneNode();
                        newWorkSheetRef.setAttribute('PartName', "/xl/worksheets/sheet".concat(newWorksheet.id, ".xml"));
                        sheetNodeRef.parentNode.insertBefore(newWorkSheetRef, sheetNodeRef.nextSibling);
                      }
                    } catch (err) {
                      _didIteratorError = true;
                      _iteratorError = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                          _iterator.return();
                        }
                      } finally {
                        if (_didIteratorError) {
                          throw _iteratorError;
                        }
                      }
                    }

                    content = fileDoc.toString();
                  } else if (fileName === 'xl/styles.xml') {
                    content = _this2.styles.xml;
                  } else if (fileName === 'xl/workbook.xml' && newWorksheets.length > 0) {
                    var sheetsNode = fileDoc.getElementsByTagName('sheets')[0];

                    for (var i = 0; i < newWorksheets.length; i++) {
                      var _newWorksheet = newWorksheets[i];
                      var newSheetNode = fileDoc.createElement('sheet');
                      newSheetNode.setAttribute('name', _newWorksheet.name);
                      newSheetNode.setAttribute('sheetId', _this2.templateInfo.lastSheetId + i + 1);
                      newSheetNode.setAttribute('r:id', "rId".concat(_this2.templateInfo.lastWorkbookRelsId + i + 1));
                      sheetsNode.appendChild(newSheetNode);
                    }

                    content = fileDoc.toString();
                  } else if (fileName === 'xl/_rels/workbook.xml.rels' && newWorksheets.length > 0) {
                    var relationshipsNode = fileDoc.getElementsByTagName('Relationships')[0];

                    for (var _i2 = 0; _i2 < newWorksheets.length; _i2++) {
                      var _newWorksheet2 = newWorksheets[_i2];
                      var newRelNode = fileDoc.createElement('Relationship');
                      newRelNode.setAttribute('Id', "rId".concat(_this2.templateInfo.lastWorkbookRelsId + _i2 + 1));
                      newRelNode.setAttribute('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet');
                      newRelNode.setAttribute('Target', "worksheets/sheet".concat(_newWorksheet2.id, ".xml"));
                      relationshipsNode.appendChild(newRelNode);
                    }

                    content = fileDoc.toString();
                  } else if (fileName === 'xl/calcChain.xml' && replacedWorksheets.length > 0) {
                    var calcChainNode = fileDoc.getElementsByTagName('calcChain')[0];
                    var cellRefNodes = Array.from(fileDoc.getElementsByTagName('c'));
                    var existingCalcCells = {};
                    cellRefNodes.forEach(function (cellRefNode) {
                      var worksheetIndex = parseInt(cellRefNode.getAttribute('i'), 10);
                      var cellRef = cellRefNode.getAttribute('r');
                      var replacedWorksheetFound = replacedWorksheets.find(function (w) {
                        return w.id === worksheetIndex;
                      });

                      if (!replacedWorksheetFound) {
                        return;
                      }

                      if (!replacedWorksheetFound.calcCells[cellRef]) {
                        cellRefNode.parentNode.removeChild(cellRefNode);
                      } else {
                        existingCalcCells[worksheetIndex] = existingCalcCells[worksheetIndex] || {};
                        existingCalcCells[worksheetIndex][cellRef] = true;
                      }
                    });
                    replacedWorksheets.forEach(function (replacedWorksheet) {
                      var calcCellsInWorksheet = existingCalcCells[replacedWorksheet.id] || {}; // eslint-disable-next-line no-restricted-syntax

                      for (var _i3 = 0, _Object$entries2 = Object.entries(replacedWorksheet.calcCells); _i3 < _Object$entries2.length; _i3++) {
                        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 1),
                            cellAddress = _Object$entries2$_i[0];

                        if (!calcCellsInWorksheet[cellAddress]) {
                          var newCellRef = fileDoc.createElement('c');
                          newCellRef.setAttribute('r', cellAddress);
                          newCellRef.setAttribute('i', replacedWorksheet.id);
                          calcChainNode.appendChild(newCellRef);
                        }
                      }
                    });
                    content = fileDoc.toString();
                  }

                  _this2.zip.append(content, {
                    name: fileName
                  });
                };

                // eslint-disable-next-line no-restricted-syntax
                for (_i = 0, _Object$entries = Object.entries(this.templateInfo.filesDocuments); _i < _Object$entries.length; _i++) {
                  _loop();
                }

                _context3.next = 23;
                break;

              case 19:
                _context3.next = 21;
                return Promise.all([this.addContentTypes(), this.addApp(), this.addCore(), this.addSharedStrings(), this.addStyles(), this.addWorkbookRels()]);

              case 21:
                _context3.next = 23;
                return this.addWorkbook();

              case 23:
                tmpWorksheetCompletePromises = [];

                this._tmpWorksheets.forEach(function (value) {
                  tmpWorksheetCompletePromises.push(value.waitComplete);
                });

                _context3.next = 27;
                return Promise.all(tmpWorksheetCompletePromises);

              case 27:
                worksheetsToCopy = []; // eslint-disable-next-line no-restricted-syntax

                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;
                _context3.prev = 31;

                for (_iterator2 = this._tmpWorksheets.entries()[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  _step2$value = _slicedToArray(_step2.value, 2), sheetId = _step2$value[0], tmpWorksheet = _step2$value[1];
                  worksheetsToCopy.push({
                    sheetId: sheetId,
                    tmpWorksheet: tmpWorksheet
                  });
                } // eslint-disable-next-line no-restricted-syntax


                _context3.next = 39;
                break;

              case 35:
                _context3.prev = 35;
                _context3.t0 = _context3["catch"](31);
                _didIteratorError2 = true;
                _iteratorError2 = _context3.t0;

              case 39:
                _context3.prev = 39;
                _context3.prev = 40;

                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                  _iterator2.return();
                }

              case 42:
                _context3.prev = 42;

                if (!_didIteratorError2) {
                  _context3.next = 45;
                  break;
                }

                throw _iteratorError2;

              case 45:
                return _context3.finish(42);

              case 46:
                return _context3.finish(39);

              case 47:
                _loop2 =
                /*#__PURE__*/
                regeneratorRuntime.mark(function _loop2() {
                  var w, sheetId, tmpWorksheet;
                  return regeneratorRuntime.wrap(function _loop2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          w = _worksheetsToCopy[_i4];
                          sheetId = w.sheetId, tmpWorksheet = w.tmpWorksheet; // eslint-disable-next-line no-await-in-loop

                          _context2.next = 4;
                          return new Promise(function (resolve, reject) {
                            var worksheetStream = fs.createReadStream(tmpWorksheet.tmpPath);
                            var decoder = new StringDecoder('utf8');
                            var placeholderFound = false;
                            var distStream = new Transform({
                              transform: function transform(chunk, enc, cb) {
                                var chunkStr = decoder.write(chunk);

                                if (!placeholderFound && chunkStr.includes('$colsContent')) {
                                  placeholderFound = true;
                                  var colsXML = _this2._worksheets[sheetId].rawColsXML;
                                  colsXML = colsXML.slice('<cols>'.length).slice(0, '</cols>'.length * -1);
                                  cb(null, chunkStr.replace('$colsContent', colsXML));
                                } else {
                                  cb(null, chunkStr);
                                }
                              },
                              flush: function flush(cb) {
                                var str = decoder.end();

                                if (str !== '') {
                                  cb(null, str);
                                } else {
                                  cb();
                                }
                              }
                            });
                            distStream.on('finish', resolve);
                            worksheetStream.on('error', reject);
                            distStream.on('error', reject);

                            _this2.zip.append(distStream, {
                              name: tmpWorksheet.zipEntryPath
                            });

                            worksheetStream.pipe(distStream);
                          });

                        case 4:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _loop2);
                });
                _i4 = 0, _worksheetsToCopy = worksheetsToCopy;

              case 49:
                if (!(_i4 < _worksheetsToCopy.length)) {
                  _context3.next = 54;
                  break;
                }

                return _context3.delegateYield(_loop2(), "t1", 51);

              case 51:
                _i4++;
                _context3.next = 49;
                break;

              case 54:
                _context3.next = 56;
                return this._finalize();

              case 56:
                result = _context3.sent;
                return _context3.abrupt("return", result);

              case 58:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee2, this, [[31, 35, 39, 47], [40,, 42, 46]]);
      }));

      function commit() {
        return _commit.apply(this, arguments);
      }

      return commit;
    }()
  }, {
    key: "addImage",
    value: function addImage(image) {
      var id = this.media.length;
      this.media.push(Object.assign({}, image, {
        type: 'image'
      }));
      return id;
    }
  }, {
    key: "getImage",
    value: function getImage(id) {
      return this.media[id];
    }
  }, {
    key: "addWorksheet",
    value: function addWorksheet(name, options) {
      // it's possible to add a worksheet with different than default
      // shared string handling
      // in fact, it's even possible to switch it mid-sheet
      options = options || {};
      var useSharedStrings = options.useSharedStrings !== undefined ? options.useSharedStrings : this.useSharedStrings;

      if (options.tabColor) {
        // eslint-disable-next-line no-console
        console.trace('tabColor option has moved to { properties: tabColor: {...} }');
        options.properties = Object.assign({
          tabColor: options.tabColor
        }, options.properties);
      }

      var id;

      if (options.id) {
        // eslint-disable-next-line prefer-destructuring
        id = options.id;
        delete options.id;
      } else {
        id = this._getNextWorksheetId(name);
      }

      name = name || "sheet".concat(id);
      var worksheet = new WorksheetWriter({
        id: id,
        name: name,
        workbook: this,
        useSharedStrings: useSharedStrings,
        properties: options.properties,
        state: options.state,
        pageSetup: options.pageSetup,
        views: options.views,
        autoFilter: options.autoFilter
      });
      this._worksheets[id] = worksheet;
      return worksheet;
    }
  }, {
    key: "addWorksheetAsync",
    value: function () {
      var _addWorksheetAsync = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(name, options) {
        var id, tmpPath;
        return regeneratorRuntime.wrap(function _callee3$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                id = this._getNextWorksheetId(name);
                _context4.next = 3;
                return new Promise(function (resolve, reject) {
                  // eslint-disable-next-line consistent-return
                  tmp.file(function (err, tmpFilePath) {
                    if (err) {
                      return reject(err);
                    }

                    resolve(tmpFilePath);
                  });
                });

              case 3:
                tmpPath = _context4.sent;

                this._tmpWorksheets.set(id, {
                  tmpPath: tmpPath
                });

                return _context4.abrupt("return", this.addWorksheet(name, _objectSpread({}, options, {
                  id: id
                })));

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee3, this);
      }));

      function addWorksheetAsync(_x, _x2) {
        return _addWorksheetAsync.apply(this, arguments);
      }

      return addWorksheetAsync;
    }()
  }, {
    key: "getWorksheet",
    value: function getWorksheet(id) {
      if (id === undefined) {
        return this._worksheets.find(function () {
          return true;
        });
      }

      if (typeof id === 'number') {
        return this._worksheets[id];
      }

      if (typeof id === 'string') {
        return this._worksheets.find(function (worksheet) {
          return worksheet && worksheet.name === id;
        });
      }

      return undefined;
    }
  }, {
    key: "addStyles",
    value: function addStyles() {
      var _this3 = this;

      return new Promise(function (resolve) {
        _this3.zip.append(_this3.styles.xml, {
          name: 'xl/styles.xml'
        });

        resolve();
      });
    }
  }, {
    key: "addThemes",
    value: function addThemes() {
      var _this4 = this;

      return new Promise(function (resolve) {
        _this4.zip.append(theme1Xml, {
          name: 'xl/theme/theme1.xml'
        });

        resolve();
      });
    }
  }, {
    key: "addOfficeRels",
    value: function addOfficeRels() {
      var _this5 = this;

      return new Promise(function (resolve) {
        var xform = new RelationshipsXform();
        var xml = xform.toXml([{
          Id: 'rId1',
          Type: RelType.OfficeDocument,
          Target: 'xl/workbook.xml'
        }, {
          Id: 'rId2',
          Type: RelType.CoreProperties,
          Target: 'docProps/core.xml'
        }, {
          Id: 'rId3',
          Type: RelType.ExtenderProperties,
          Target: 'docProps/app.xml'
        }]);

        _this5.zip.append(xml, {
          name: '/_rels/.rels'
        });

        resolve();
      });
    }
  }, {
    key: "addContentTypes",
    value: function addContentTypes() {
      var _this6 = this;

      return new Promise(function (resolve) {
        var model = {
          worksheets: _this6._worksheets.filter(Boolean),
          sharedStrings: _this6.sharedStrings,
          commentRefs: _this6.commentRefs,
          media: _this6.media
        };
        var xform = new ContentTypesXform();
        var xml = xform.toXml(model);

        _this6.zip.append(xml, {
          name: '[Content_Types].xml'
        });

        resolve();
      });
    }
  }, {
    key: "addMedia",
    value: function addMedia() {
      var _this7 = this;

      return Promise.all(this.media.map(function (medium, idx) {
        medium.name = "image".concat(idx + 1, ".").concat(medium.extension);

        if (medium.type === 'image') {
          var filename = "xl/media/".concat(medium.name);

          if (medium.filename) {
            return _this7.zip.file(medium.filename, {
              name: filename
            });
          }

          if (medium.buffer) {
            return _this7.zip.append(medium.buffer, {
              name: filename
            });
          }

          if (medium.base64) {
            var dataimg64 = medium.base64;
            var content = dataimg64.substring(dataimg64.indexOf(',') + 1);
            return _this7.zip.append(content, {
              name: filename,
              base64: true
            });
          }
        }

        throw new Error('Unsupported media');
      }));
    }
  }, {
    key: "addApp",
    value: function addApp() {
      var _this8 = this;

      return new Promise(function (resolve) {
        var model = {
          worksheets: _this8._worksheets.filter(Boolean)
        };
        var xform = new AppXform();
        var xml = xform.toXml(model);

        _this8.zip.append(xml, {
          name: 'docProps/app.xml'
        });

        resolve();
      });
    }
  }, {
    key: "addCore",
    value: function addCore() {
      var _this9 = this;

      return new Promise(function (resolve) {
        var coreXform = new CoreXform();
        var xml = coreXform.toXml(_this9);

        _this9.zip.append(xml, {
          name: 'docProps/core.xml'
        });

        resolve();
      });
    }
  }, {
    key: "addSharedStrings",
    value: function addSharedStrings() {
      var _this10 = this;

      if (this.sharedStrings.count) {
        return new Promise(function (resolve) {
          var sharedStringsXform = new SharedStringsXform();
          var xml = sharedStringsXform.toXml(_this10.sharedStrings);

          _this10.zip.append(xml, {
            name: '/xl/sharedStrings.xml'
          });

          resolve();
        });
      }

      return Promise.resolve();
    }
  }, {
    key: "addWorkbookRels",
    value: function addWorkbookRels() {
      var _this11 = this;

      var count = 1;
      var relationships = [{
        Id: "rId".concat(count++),
        Type: RelType.Styles,
        Target: 'styles.xml'
      }, {
        Id: "rId".concat(count++),
        Type: RelType.Theme,
        Target: 'theme/theme1.xml'
      }];

      if (this.sharedStrings.count) {
        relationships.push({
          Id: "rId".concat(count++),
          Type: RelType.SharedStrings,
          Target: 'sharedStrings.xml'
        });
      }

      this._worksheets.forEach(function (worksheet) {
        if (worksheet) {
          worksheet.rId = "rId".concat(count++);
          relationships.push({
            Id: worksheet.rId,
            Type: RelType.Worksheet,
            Target: "worksheets/sheet".concat(worksheet.id, ".xml")
          });
        }
      });

      return new Promise(function (resolve) {
        var xform = new RelationshipsXform();
        var xml = xform.toXml(relationships);

        _this11.zip.append(xml, {
          name: '/xl/_rels/workbook.xml.rels'
        });

        resolve();
      });
    }
  }, {
    key: "addWorkbook",
    value: function addWorkbook() {
      var zip = this.zip;
      var model = {
        worksheets: this._worksheets.filter(Boolean),
        definedNames: this._definedNames.model,
        views: this.views,
        properties: {},
        calcProperties: {}
      };
      return new Promise(function (resolve) {
        var xform = new WorkbookXform();
        xform.prepare(model);
        zip.append(xform.toXml(model), {
          name: '/xl/workbook.xml'
        });
        resolve();
      });
    }
  }, {
    key: "_finalize",
    value: function _finalize() {
      var _this12 = this;

      return new Promise(function (resolve, reject) {
        _this12.stream.on('error', reject);

        _this12.stream.on('finish', function () {
          resolve(_this12);
        });

        _this12.zip.on('error', reject);

        _this12.zip.finalize();
      });
    }
  }, {
    key: "definedNames",
    get: function get() {
      return this._definedNames;
    }
  }, {
    key: "nextId",
    get: function get() {
      var id; // find the next unique spot to add worksheet

      var i;

      for (i = 1; i < this._worksheets.length; i++) {
        if (!this._worksheets[i]) {
          id = i;
          break;
        }
      }

      if (id == null) {
        id = this._worksheets.length || 1;
      }

      if (this.templateInfo && this.templateInfo.lastSheetFileId != null) {
        return this.templateInfo.lastSheetFileId + id;
      }

      return id;
    }
  }]);

  return WorkbookWriter;
}();

function parseXMLFile(_x3, _x4) {
  return _parseXMLFile.apply(this, arguments);
}

function _parseXMLFile() {
  _parseXMLFile = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee4(files, entry) {
    var xml, doc;
    return regeneratorRuntime.wrap(function _callee4$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return entry.buffer();

          case 2:
            xml = _context5.sent.toString();
            doc = new DOMParser().parseFromString(xml);
            files[entry.path] = {
              originalSrc: xml,
              doc: doc
            };

          case 5:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee4);
  }));
  return _parseXMLFile.apply(this, arguments);
}

module.exports = WorkbookWriter;
//# sourceMappingURL=workbook-writer.js.map

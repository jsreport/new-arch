const extend = require('node.extend.without.arrays')

async function resolveCurrentPath (reporter, req) {
  if (!req.template) {
    return null
  }

  const pathFragments = []
  let currentFolder = req.template.folder

  if (currentFolder) {
    currentFolder = await reporter.documentStore.collection('folders').findOne({shortid: currentFolder.shortid}, req)
  }

  while (currentFolder) {
    pathFragments.push(currentFolder.name)

    if (!currentFolder.folder) {
      currentFolder = null
    } else {
      currentFolder = await reporter.documentStore.collection('folders').findOne({shortid: currentFolder.folder.shortid}, req)
    }
  }

  return '/' + pathFragments.reverse().join('/')
}

const beforeRender = (reporter) => async (req, res) => {
  if (!req.template._id && !req.template.shortid && !req.template.name) {
    if (!req.template.content) {
      throw reporter.createError('Template must contains _id, shortid or content attribute', {
        weak: true,
        statusCode: 400
      })
    }

    reporter.logger.info(
      `Rendering anonymous template { recipe: ${req.template.recipe}, engine: ${req.template.engine} }`,
      req
    )

    return
  }

  async function findTemplate () {
    async function findQuery () {
      if (req.template._id) {
        return {
          query: { _id: req.template._id },
          meta: { field: '_id', value: req.template._id }
        }
      }

      if (req.template.shortid) {
        return {
          query: { shortid: req.template.shortid },
          meta: { field: 'shortid', value: req.template.shortid }
        }
      }
    }

    const queryResult = await findQuery()
    const meta = {}
    let templates = []

    if (queryResult) {
      meta.field = queryResult.meta.field
      meta.value = queryResult.meta.value
      templates = await reporter.documentStore.collection('templates').find(queryResult.query, req)
    } else if (req.template.name) {
      const nameIsPath = req.template.name.indexOf('/') !== -1

      meta.field = 'name'
      meta.value = req.template.name

      if (!req.template.name.startsWith('/') && nameIsPath) {
        throw reporter.createError('Invalid template path, path should be absolute and start with "/"', {
          statusCode: 400,
          weak: true
        })
      }

      const pathParts = req.template.name.split('/').filter((p) => p)

      if (pathParts.length === 0) {
        throw reporter.createError('Invalid template path, path should be absolute and target something', {
          statusCode: 400,
          weak: true
        })
      }

      if (!nameIsPath) {
        // if name is not path do global search by name (with no folder).
        // since template name resolution here does not support relative syntax we should not run
        // resolveEntityFromPath if the name is not path
        templates = await reporter.documentStore.collection('templates').find({
          name: req.template.name
        }, req)
      } else {
        const result = await reporter.folders.resolveEntityFromPath(req.template.name, 'templates', req)

        if (result) {
          templates = [result.entity]
        }
      }
    } else {
      return req.template
    }

    let template

    if (templates.length > 1) {
      throw reporter.createError(`Duplicated templates found for query ${meta.field}: ${meta.value}`, {
        statusCode: 400,
        weak: true
      })
    }

    if (templates.length === 1) {
      template = templates[0]
    }

    return template
  }

  const template = await findTemplate()

  if (!template && !req.template.content) {
    throw reporter.createError(`Unable to find specified template or user doesnt have permissions to read it: ${
      (req.template._id || req.template.shortid || req.template.name)
    }`, {
      weak: true,
      statusCode: 404
    })
  }

  req.context.renderHierarchy = req.context.renderHierarchy || []

  if (template && template._id != null) {
    if (req.context.renderHierarchy.length > 0 && req.context.renderHierarchy.some((tid) => tid === template._id)) {
      const hierarchyPaths = await Promise.all(req.context.renderHierarchy.map(async (tid) => {
        const t = await reporter.documentStore.collection('templates').findOne({ _id: tid }, req)
        const cp = await reporter.folders.resolveEntityPath(t, 'templates', req)
        return cp
      }))

      const currentT = await reporter.documentStore.collection('templates').findOne({ _id: template._id }, req)
      const currentPath = await reporter.folders.resolveEntityPath(currentT, 'templates', req)
      const hierarchyMsg = `${[...hierarchyPaths, currentPath].join(' -> ')}`
      const duplicatedTemplateMsg = `${currentPath}`

      throw reporter.createError(`Render cycle detected. Template at ${duplicatedTemplateMsg} was rendered previously in this render request (hierarchy: ${hierarchyMsg}). Please verify that reporter.render is not causing cycle`, {
        weak: true,
        statusCode: 403
      })
    }

    req.context.renderHierarchy.push(template._id)
  }

  req.template = template ? extend(true, template, req.template) : req.template
  req.template.content = req.template.content || ''

  reporter.logger.info(
    `Rendering template { name: ${req.template.name}, recipe: ${req.template.recipe}, engine: ${req.template.engine}, preview: ${(req.options.preview || false)} }`,
    req
  )

  if (!req.options.reportName && req.template.name) {
    res.meta.reportName = req.template.name
  }

  req.context.currentFolderPath = await resolveCurrentPath(reporter, req)
}

module.exports = (reporter, definition) => {
    reporter.beforeRenderListeners.add('templates', beforeRender(reporter, definition))
}